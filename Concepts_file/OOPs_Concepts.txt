OOPs Concepts:
i. Class and Object:
⦁A class is a blueprint or template that defines the properties (variables) and behaviors (methods) of objects. It does not occupy memory until an object is created.
⦁An object is a real-world instance of a class that has its own state (data) and behavior (methods).It is created from a class using the new keyword.
ii. Constructor and it's overloading:
⦁A constructor is a special method in a class that is used to initialize objects.It has the same name as the class and does not have a return type.It is called automatically when an object is created.
⦁Constructor overloading means having more than one constructor in the same class with different parameter lists.It allows you to create objects in different ways (with or without initial values).
iii. Static Members:
⦁Static Variable: A static variable belongs to the class, not to any specific object.It is shared by all objects of the class.
⦁Static Method: A static method can be called without creating an object of the class. It can access only static variables directly.
⦁Static Block: A static block runs once when the class is loaded into memory. It is used to initialize static data.
iv. Final Keyword: 
⦁Final Variable: A final variable value cannot be changed once assigned. Example: final int x = 10;
⦁Final Method: A final method cannot be overridden in a subclass.Example:    class A {final void display() {System.out.println("Hello");}}
⦁Final Class: A final class cannot be inherited by any other class. Example:         final class A { }class B extends A { }
v. Access Modifier:
Access modifiers define the visibility (where a member can be accessed) of classes, variables, and methods.
⦁public: Can be accessed from anywhere — inside or outside the class, even from other packages.
⦁private: Can be accessed only within the same class. It is not visible to other classes.
⦁protected: Can be accessed within the same package and also by subclasses (even in other packages)
⦁default (no modifier): If no modifier is used, it is accessible only within the same package.
vi. Encapsulation: 
Encapsulation means binding data (variables) and methods (functions) together in a single unit (class). It is used to protect data by keeping it private and providing public getter and setter methods to access it.
Example:
class Student {
    private int id;
    private String name;
    public void setId(int i) {id = i;}
    public void setName(String n) {name = n;}
    public int getId() {return id;}
    public String getName() {return name;}
}
class Test {
    public static void main(String[] args) {
        Student s = new Student();
        s.setId(101);
        s.setName("Dharshini");
        System.out.println(s.getId() + " " + s.getName());
    }
}
vi. Inheritance:
Inheritance is the process where one class (child) gets the properties and methods of another class (parent). It helps in code reusability and method overriding.
1. Single Inheritance: One class inherits from another single class.
class A {
    void display() {System.out.println("Class A");}
}

class B extends A {
    void show() {System.out.println("Class B");}
}
B inherits from A.
2. Multilevel Inheritance: A class inherits from another class, which itself is inherited from another.
class A { void showA() { } }
class B extends A { void showB() { } }
class C extends B { void showC() { } }
C inherits from B, and B inherits from A.
3. Hierarchical Inheritance: Multiple classes inherit from the same parent class.
class A { void showA() { } }
class B extends A { void showB() { } }
class C extends A { void showC() { } }
Both B and C inherit from A.
vii. Polymorphism: 
Polymorphism means "many forms" — the same method or operation behaves differently based on the object or situation. It allows one name to have multiple behaviors.
1. Compile-time Polymorphism (Method Overloading): Happens when multiple methods in the same class have the same name but different parameters. The method is decided at compile time.
Example:
class Calculator {
    int add(int a, int b) {return a + b;}
    int add(int a, int b, int c) {return a + b + c;}
}
The correct add() method is chosen during compilation.
2. Runtime Polymorphism (Method Overriding): Happens when a child class provides a new implementation for a method that is already defined in its parent class. The method is decided at runtime.
Example:
class Animal {
    void sound() {System.out.println("Animal sound");}
}
class Dog extends Animal {
    void sound() {System.out.println("Bark");}
}
class Test {
    public static void main(String[] args) {
        Animal a = new Dog(); 
        a.sound(); 
    }
}
viii. Abstraction:
Abstraction means showing only essential features and hiding the internal details. It focuses on what an object does, not how it does it.
Abstraction can be achieved in two ways:
1.	Using Abstract Classes
2.	Using Interfaces

1. Abstract Class: A class declared with the keyword abstract. It can have abstract methods (without body) and non-abstract methods (with body). It cannot be instantiated (objects cannot be created directly). It is used for partial abstraction.
Example:
abstract class Animal {
    abstract void sound();      
    void sleep() {System.out.println("Sleeping");}
}
class Dog extends Animal {
    void sound() {System.out.println("Bark");}
}
2. Interface:
An interface is a blueprint of a class that contains abstract methods (methods without a body). It is used to achieve abstraction and multiple inheritance in Java. A class that uses an interface must implement all its methods.
⦁Declared using the keyword interface.
⦁All methods are public and abstract by default.
⦁A class uses the keyword implements to use an interface.
⦁One class can implement multiple interfaces.
⦁Interfaces help in loose coupling and code reusability.
Example:
import java.util.*;
interface Calculator
{
    double add(double a, double b);
    double sub(double a, double b);
    double mul(double a, double b);
    double div(double a, double b);
}
interface Scientific {double power(double a, double b);}
class BasicCalculator implements Scientific,Calculator­­­
{­­­
    public double add(double a, double b){return a+b;}
    public double sub(double a, double b) {return a-b;}­
    public double mul(double a, double b) {return a*b;}
    public double div(double a, double b){return a/b;}
    public double power(double a, double b){ return Math.pow(a,b);}
}
public class App {
    public static void main(String[] args)
    {
        Scanner s=new Scanner(System.in);
        BasicCalculator app=new BasicCalculator();
        System.out.println("Enter first Value: ");
        double a=s.nextDouble();
        System.out.println("Enter Second Value: ");
        double b=s.nextDouble();
        System.out.println("Enter Any Symbol(+,-,*,/,^): ");
        char sys=s.next().charAt(0);
        double ans;
        switch(sys)
        {
            case '+':
                ans=app.add(a,b);
                System.out.println("Answer: "+ans);
                break;
            case '-':
                ans=app.sub(a,b);
                System.out.println("Answer: "+ans);
                break;
            case '*':
                ans=app.mul(a,b);
                System.out.println("Answer: "+ans);
                break;
            case '/':
                ans=app.div(a,b);
                System.out.println("Answer: "+ans);
                break;
            case '^':
                ans=app.power(a,b);
                System.out.println("Answer: "+ans);
                break;
}}}
