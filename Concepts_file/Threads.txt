A thread in Java is a lightweight subprocess — the smallest unit of execution. When you run a Java program, there is always at least one thread running called the main thread. Threads allow multiple parts of a program to run concurrently, which helps in performing multiple tasks at the same time.
For example, in a web browser, one thread can handle user input while another loads data in the background.
Creating Threads
There are two main ways to create a thread in Java:
1. By Extending the Thread Class: You can create a thread by extending the Thread class and overriding the run() method.
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread is running...");
    }
}
public class Demo {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start(); // starts the thread and calls run()
    }
}
start() creates a new thread and calls the run() method internally.
2. By Implementing the Runnable Interface: This is the preferred way because Java does not support multiple inheritance. Using Runnable, your class can extend another class and still define thread behavior.

class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Runnable thread is running...");
    }
}
public class Demo {
    public static void main(String[] args) {
        Thread t = new Thread(new MyRunnable());
        t.start();
    }
}
Here, Runnable is a functional interface, meaning it has only one abstract method (run()).
Thread States:
1. New State: When a thread is created but not yet started. The thread object exists, but no system resources are allocated yet.
Thread t = new Thread(); 
2. Start / Runnable State: When you call the start() method, the thread moves from new to runnable. It means the thread is ready to run and waiting for the CPU to schedule it. It may start running immediately or after some time depending on the CPU.
t.start(); 
3. Running State: When the CPU picks the thread, it starts executing the code inside the run() method.A thread can move back and forth between runnable and running based on CPU scheduling.
public void run() {
    System.out.println("Thread is running...");
}
4. Sleep / Waiting State: A thread enters sleeping or waiting state when it temporarily stops execution. It can happen because:
You call Thread.sleep(time) (sleeping)
You call wait() (waiting for another thread)
It’s waiting to acquire a lock (blocked)
The thread goes back to runnable once the waiting time is over or another thread notifies it.
try {
    Thread.sleep(1000); // TIMED_WAITING
} catch (InterruptedException e) {
    e.printStackTrace();
}
5. Dead (Terminated) State: When the run() method finishes, the thread’s life ends. Once a thread is dead, it cannot be restarted.
System.out.println("Thread finished!");
Thread Lifecycle:
NEW  →  RUNNABLE  →  RUNNING  →  WAITING/SLEEPING  →  DEAD
Example Flow:
Thread created → NEW
start() called → RUNNABLE
CPU executes → RUNNING
sleep() or wait() → WAITING
Task finished → DEAD
